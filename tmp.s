.intel_syntax noprefix
.data
.align 8
.L.data.strings.0:
   .quad 9
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x3a 
   .byte 0x20 
   .byte 0x6f 
   .byte 0x6b 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.1:
   .quad 11
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x3a 
   .byte 0x20 
   .byte 0x66 
   .byte 0x61 
   .byte 0x69 
   .byte 0x6c 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.2:
   .quad 9
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x3a 
   .byte 0x20 
   .byte 0x6f 
   .byte 0x6b 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.3:
   .quad 11
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x3a 
   .byte 0x20 
   .byte 0x66 
   .byte 0x61 
   .byte 0x69 
   .byte 0x6c 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.4:
   .quad 13
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x69 
   .byte 0x6e 
   .byte 0x67 
   .byte 0x20 
   .byte 0x6c 
   .byte 0x6f 
   .byte 0x6f 
   .byte 0x70 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.5:
   .quad 23
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x69 
   .byte 0x6e 
   .byte 0x67 
   .byte 0x20 
   .byte 0x6c 
   .byte 0x6f 
   .byte 0x6f 
   .byte 0x70 
   .byte 0x20 
   .byte 0x69 
   .byte 0x6e 
   .byte 0x74 
   .byte 0x65 
   .byte 0x67 
   .byte 0x72 
   .byte 0x69 
   .byte 0x74 
   .byte 0x79 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.6:
   .quad 11
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x69 
   .byte 0x6e 
   .byte 0x67 
   .byte 0x20 
   .byte 0x69 
   .byte 0x38 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.7:
   .quad 12
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x69 
   .byte 0x6e 
   .byte 0x67 
   .byte 0x20 
   .byte 0x69 
   .byte 0x31 
   .byte 0x36 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.8:
   .quad 12
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x69 
   .byte 0x6e 
   .byte 0x67 
   .byte 0x20 
   .byte 0x69 
   .byte 0x33 
   .byte 0x32 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.9:
   .quad 12
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x69 
   .byte 0x6e 
   .byte 0x67 
   .byte 0x20 
   .byte 0x69 
   .byte 0x36 
   .byte 0x34 
   .byte 0xa 
   .byte 0
.align 8
.L.data.strings.10:
   .quad 38
   .byte 0x54 
   .byte 0x6f 
   .byte 0x74 
   .byte 0x61 
   .byte 0x6c 
   .byte 0x20 
   .byte 0x74 
   .byte 0x65 
   .byte 0x73 
   .byte 0x74 
   .byte 0x73 
   .byte 0x3a 
   .byte 0x20 
   .byte 0x25 
   .byte 0x64 
   .byte 0xa 
   .byte 0x70 
   .byte 0x61 
   .byte 0x73 
   .byte 0x73 
   .byte 0x65 
   .byte 0x64 
   .byte 0x3a 
   .byte 0x20 
   .byte 0x25 
   .byte 0x64 
   .byte 0xa 
   .byte 0x66 
   .byte 0x61 
   .byte 0x69 
   .byte 0x6c 
   .byte 0x65 
   .byte 0x64 
   .byte 0x3a 
   .byte 0x20 
   .byte 0x25 
   .byte 0x64 
   .byte 0xa 
   .byte 0
.align 8
.L.data.anon.0:
   .quad 9
   .quad offset .L.data.strings.0 + 8
.align 8
.L.data.anon.1:
   .quad 11
   .quad offset .L.data.strings.1 + 8
.align 8
.L.data.anon.2:
   .quad 9
   .quad offset .L.data.strings.2 + 8
.align 8
.L.data.anon.3:
   .quad 11
   .quad offset .L.data.strings.3 + 8
.align 8
.L.data.anon.4:
   .quad 13
   .quad offset .L.data.strings.4 + 8
.align 8
.L.data.anon.5:
   .quad 23
   .quad offset .L.data.strings.5 + 8
.align 8
.L.data.anon.6:
   .quad 11
   .quad offset .L.data.strings.6 + 8
.align 8
.L.data.anon.7:
   .quad 12
   .quad offset .L.data.strings.7 + 8
.align 8
.L.data.anon.8:
   .quad 12
   .quad offset .L.data.strings.8 + 8
.align 8
.L.data.anon.9:
   .quad 12
   .quad offset .L.data.strings.9 + 8
.align 4
total:
   .4byte 0
.align 4
passed:
   .4byte 0
.align 4
failed:
   .4byte 0
.bss
.text
.global write
write:
   push rbp
   mov rbp, rsp
   sub rsp, 16
   mov [rbp-8], rdi
# [inline asm]
   mov rsi, [rdi+8]
   mov rdx, [rdi +0]
   mov rdi, 1
   mov rax, 1
   syscall
# [end]
   xor rax, rax
.L.endfn.0:
   mov rsp, rbp
   pop rbp
   ret

.global test
test:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-1], dil
# assign variable
# generate address of variable
# load address of var
   push offset total
   pop rax
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   push offset total
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
# load address of var
   lea rax, [rbp-1]
# load
   movsx rax, byte ptr [rax]
# end load
   cmp rax, 0
   je .L.else.2
   lea rax, .L.data.anon.0
   push rax
   pop rdi
   call write
# assign variable
# generate address of variable
# load address of var
   push offset passed
   pop rax
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   push offset passed
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.end.2
.L.else.2:
   lea rax, .L.data.anon.1
   push rax
   pop rdi
   call write
# assign variable
# generate address of variable
# load address of var
   push offset failed
   pop rax
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   push offset failed
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
.L.end.2:
   xor rax, rax
.L.endfn.1:
   mov rsp, rbp
   pop rbp
   ret

.global test_eql
test_eql:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-1], dil
   mov [rbp-2], sil
# assign variable
# generate address of variable
# load address of var
   push offset total
   pop rax
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   push offset total
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, byte ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-1]
# load
   movsx rax, byte ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   sete al
   movzb rax, al
   cmp rax, 0
   je .L.else.4
   lea rax, .L.data.anon.2
   push rax
   pop rdi
   call write
# assign variable
# generate address of variable
# load address of var
   push offset passed
   pop rax
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   push offset passed
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.end.4
.L.else.4:
# assign variable
# generate address of variable
# load address of var
   push offset failed
   pop rax
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   push offset failed
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   lea rax, .L.data.anon.3
   push rax
   pop rdi
   call write
.L.end.4:
   xor rax, rax
.L.endfn.3:
   mov rsp, rbp
   pop rbp
   ret

.global add_u8
add_u8:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-1], dil
   mov [rbp-2], sil
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, byte ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-1]
# load
   movsx rax, byte ptr [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.5
   xor rax, rax
.L.endfn.5:
   mov rsp, rbp
   pop rbp
   ret

.global add_u16
add_u16:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-2], di
   mov [rbp-4], si
# load address of var
   lea rax, [rbp-4]
# load
   movsx rax, word ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, word ptr [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.6
   xor rax, rax
.L.endfn.6:
   mov rsp, rbp
   pop rbp
   ret

.global add_u32
add_u32:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-4], edi
   mov [rbp-8], esi
# load address of var
   lea rax, [rbp-8]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.7
   xor rax, rax
.L.endfn.7:
   mov rsp, rbp
   pop rbp
   ret

.global add_u64
add_u64:
   push rbp
   mov rbp, rsp
   sub rsp, 16
   mov [rbp-8], rdi
   mov [rbp-16], rsi
# load address of var
   lea rax, [rbp-16]
# load
   mov rax, [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-8]
# load
   mov rax, [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.8
   xor rax, rax
.L.endfn.8:
   mov rsp, rbp
   pop rbp
   ret

.global add_i8
add_i8:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-1], dil
   mov [rbp-2], sil
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, byte ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-1]
# load
   movsx rax, byte ptr [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.9
   xor rax, rax
.L.endfn.9:
   mov rsp, rbp
   pop rbp
   ret

.global add_i16
add_i16:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-2], di
   mov [rbp-4], si
# load address of var
   lea rax, [rbp-4]
# load
   movsx rax, word ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, word ptr [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.10
   xor rax, rax
.L.endfn.10:
   mov rsp, rbp
   pop rbp
   ret

.global add_i32
add_i32:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-4], edi
   mov [rbp-8], esi
# load address of var
   lea rax, [rbp-8]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.11
   xor rax, rax
.L.endfn.11:
   mov rsp, rbp
   pop rbp
   ret

.global add_i64
add_i64:
   push rbp
   mov rbp, rsp
   sub rsp, 16
   mov [rbp-8], rdi
   mov [rbp-16], rsi
# load address of var
   lea rax, [rbp-16]
# load
   mov rax, [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-8]
# load
   mov rax, [rax]
# end load
   pop rdi
   add rax, rdi
   jmp .L.endfn.12
   xor rax, rax
.L.endfn.12:
   mov rsp, rbp
   pop rbp
   ret

.global div_i8
div_i8:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-1], dil
   mov [rbp-2], sil
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, byte ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-1]
# load
   movsx rax, byte ptr [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   jmp .L.endfn.13
   xor rax, rax
.L.endfn.13:
   mov rsp, rbp
   pop rbp
   ret

.global div_i16
div_i16:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-2], di
   mov [rbp-4], si
# load address of var
   lea rax, [rbp-4]
# load
   movsx rax, word ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, word ptr [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   jmp .L.endfn.14
   xor rax, rax
.L.endfn.14:
   mov rsp, rbp
   pop rbp
   ret

.global div_i32
div_i32:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-4], edi
   mov [rbp-8], esi
# load address of var
   lea rax, [rbp-8]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   jmp .L.endfn.15
   xor rax, rax
.L.endfn.15:
   mov rsp, rbp
   pop rbp
   ret

.global div_i64
div_i64:
   push rbp
   mov rbp, rsp
   sub rsp, 16
   mov [rbp-8], rdi
   mov [rbp-16], rsi
# load address of var
   lea rax, [rbp-16]
# load
   mov rax, [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-8]
# load
   mov rax, [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   jmp .L.endfn.16
   xor rax, rax
.L.endfn.16:
   mov rsp, rbp
   pop rbp
   ret

.global mul_i8
mul_i8:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-1], dil
   mov [rbp-2], sil
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, byte ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-1]
# load
   movsx rax, byte ptr [rax]
# end load
   pop rdi
   imul rax, rdi
   jmp .L.endfn.17
   xor rax, rax
.L.endfn.17:
   mov rsp, rbp
   pop rbp
   ret

.global mul_i16
mul_i16:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-2], di
   mov [rbp-4], si
# load address of var
   lea rax, [rbp-4]
# load
   movsx rax, word ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, word ptr [rax]
# end load
   pop rdi
   imul rax, rdi
   jmp .L.endfn.18
   xor rax, rax
.L.endfn.18:
   mov rsp, rbp
   pop rbp
   ret

.global mul_i32
mul_i32:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-4], edi
   mov [rbp-8], esi
# load address of var
   lea rax, [rbp-8]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   imul rax, rdi
   jmp .L.endfn.19
   xor rax, rax
.L.endfn.19:
   mov rsp, rbp
   pop rbp
   ret

.global mul_i64
mul_i64:
   push rbp
   mov rbp, rsp
   sub rsp, 16
   mov [rbp-8], rdi
   mov [rbp-16], rsi
# load address of var
   lea rax, [rbp-16]
# load
   mov rax, [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-8]
# load
   mov rax, [rax]
# end load
   pop rdi
   imul rax, rdi
   jmp .L.endfn.20
   xor rax, rax
.L.endfn.20:
   mov rsp, rbp
   pop rbp
   ret

.global sub_i8
sub_i8:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-1], dil
   mov [rbp-2], sil
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, byte ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-1]
# load
   movsx rax, byte ptr [rax]
# end load
   pop rdi
   sub rax, rdi
   jmp .L.endfn.21
   xor rax, rax
.L.endfn.21:
   mov rsp, rbp
   pop rbp
   ret

.global sub_i16
sub_i16:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-2], di
   mov [rbp-4], si
# load address of var
   lea rax, [rbp-4]
# load
   movsx rax, word ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-2]
# load
   movsx rax, word ptr [rax]
# end load
   pop rdi
   sub rax, rdi
   jmp .L.endfn.22
   xor rax, rax
.L.endfn.22:
   mov rsp, rbp
   pop rbp
   ret

.global sub_i32
sub_i32:
   push rbp
   mov rbp, rsp
   sub rsp, 8
   mov [rbp-4], edi
   mov [rbp-8], esi
# load address of var
   lea rax, [rbp-8]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   sub rax, rdi
   jmp .L.endfn.23
   xor rax, rax
.L.endfn.23:
   mov rsp, rbp
   pop rbp
   ret

.global sub_i64
sub_i64:
   push rbp
   mov rbp, rsp
   sub rsp, 16
   mov [rbp-8], rdi
   mov [rbp-16], rsi
# load address of var
   lea rax, [rbp-16]
# load
   mov rax, [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-8]
# load
   mov rax, [rax]
# end load
   pop rdi
   sub rax, rdi
   jmp .L.endfn.24
   xor rax, rax
.L.endfn.24:
   mov rsp, rbp
   pop rbp
   ret

.global main
main:
   push rbp
   mov rbp, rsp
   sub rsp, 24
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 0
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   lea rax, .L.data.anon.4
   push rax
   pop rdi
   call write
.L.continue.27:
   mov rax, 50
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   setl al
   movzb rax, al
   cmp rax, 0
   je .L.break.27
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   pop rsi
   pop rdi
   call test_eql
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.continue.27
.L.break.27:
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 0
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   lea rax, .L.data.anon.5
   push rax
   pop rdi
   call write
.L.continue.28:
   mov rax, 50
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   setl al
   movzb rax, al
   cmp rax, 0
   je .L.break.28
   mov rax, 50
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   setl al
   movzb rax, al
   push rax
   mov rax, 1
   push rax
   pop rsi
   pop rdi
   call test_eql
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.continue.28
.L.break.28:
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 0
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   lea rax, .L.data.anon.6
   push rax
   pop rdi
   call write
.L.continue.29:
   mov rax, 50
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   setl al
   movzb rax, al
   cmp rax, 0
   je .L.break.29
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 10
   push rax
   pop rsi
   pop rdi
   call add_i8
   push rax
   mov rax, 10
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call div_i8
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call mul_i8
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   imul rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 20
   push rax
   pop rsi
   pop rdi
   call sub_i8
   push rax
   mov rax, 20
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   sub rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.continue.29
.L.break.29:
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 0
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   lea rax, .L.data.anon.7
   push rax
   pop rdi
   call write
.L.continue.30:
   mov rax, 50
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   setl al
   movzb rax, al
   cmp rax, 0
   je .L.break.30
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 20
   push rax
   pop rsi
   pop rdi
   call add_i16
   push rax
   mov rax, 20
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call div_i16
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call mul_i32
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   imul rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 20
   push rax
   pop rsi
   pop rdi
   call sub_i64
   push rax
   mov rax, 20
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   sub rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.continue.30
.L.break.30:
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 0
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   lea rax, .L.data.anon.8
   push rax
   pop rdi
   call write
.L.continue.31:
   mov rax, 50
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   setl al
   movzb rax, al
   cmp rax, 0
   je .L.break.31
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 20
   push rax
   pop rsi
   pop rdi
   call add_i32
   push rax
   mov rax, 20
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call div_i32
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call mul_i32
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   imul rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 20
   push rax
   pop rsi
   pop rdi
   call sub_i32
   push rax
   mov rax, 20
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   sub rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.continue.31
.L.break.31:
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 0
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   lea rax, .L.data.anon.9
   push rax
   pop rdi
   call write
.L.continue.32:
   mov rax, 50
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cmp rax, rdi
   setl al
   movzb rax, al
   cmp rax, 0
   je .L.break.32
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 20
   push rax
   pop rsi
   pop rdi
   call add_i64
   push rax
   mov rax, 20
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call div_i64
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   cqo
   idiv rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 2
   push rax
   pop rsi
   pop rdi
   call mul_i64
   push rax
   mov rax, 2
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   imul rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   mov rax, 20
   push rax
   pop rsi
   pop rdi
   call sub_i64
   push rax
   mov rax, 20
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   sub rax, rdi
   push rax
   pop rsi
   pop rdi
   call test_eql
# assign variable
# generate address of variable
# load address of var
   lea rax, [rbp-4]
# address of variable generated
   push rax
# generate value to assign
   mov rax, 1
   push rax
# load address of var
   lea rax, [rbp-4]
# load
   movsxd rax, dword ptr [rax]
# end load
   pop rdi
   add rax, rdi
# store value to variable address
# store
   pop rdi
   mov [rdi], eax
# end store
   jmp .L.continue.32
.L.break.32:
# assign slice
   mov rax, 0
mov rdx, rax
   push rax
   mov rax, 38
   pop rdi
   sub rax, rdi
mov rcx, rax
# load address of var
   lea rax, [rbp-24]
mov [rax], rcx
add rax, 8
   push rax
   lea rax, .L.data.strings.10
add rax, 8
imul rdx, 1
add rax, rdx
   pop rdi
mov [rdi], rax
# getting struct member
# load address of var
   lea rax, [rbp-24]
# add offset of member
   add rax, 8
# end add offset
# load
   mov rax, [rax]
# end load
   push rax
# load address of var
   push offset total
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   push offset passed
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
# load address of var
   push offset failed
   pop rax
# load
   movsxd rax, dword ptr [rax]
# end load
   push rax
   pop rcx
   pop rdx
   pop rsi
   pop rdi
   lea r15, printf
   call buitin_glibc_caller
   xor rax, rax
.L.endfn.26:
   mov rsp, rbp
   pop rbp
   ret

.global buitin_glibc_caller
buitin_glibc_caller:
   push rbp
   mov rbp, rsp
   mov rax, rsp
   and rax, 15
   jnz .L.call
   mov rax, 0
   call r15
   jmp .L.end
.L.call:
   sub rsp, 8
   mov rax, 0
   call r15
   add rsp, 8
.L.end:
   mov rsp, rbp
   pop rbp
   ret
