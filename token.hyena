enum TokType {
    _plus,
    _minus,
    _multiply,
    _divide,
    _number,
    _undef,
    _leftparen,
    _rightparen,
    _semicolon,
    _colon,
    _identifier,
    _var,
    _equal,
    _leftbrace,
    _rightbrace,
    _bang,
    _greater,
    _less,
    _if,
    _else,
    _while,
    _break,
    _continue,
    _extern,
    _fn,
    _dot,
    _comma,
    _string,
    _return,
    _struct,
    _leftsquare,
    _rightsquare,
    _mod,
    _u8,
    _u16,
    _u32,
    _u64,
    _i8,
    _i16,
    _i32,
    _i64,
    _f32,
    _f64,
    _void,
    _true,
    _false,
    _bool,
    _eq,
    _neq,
    _lte,
    _gte,
    _union,
    _enum,
    _at,
    _and,
    _or,
    _bitxor,
    _bitand,
    _bitor,
    _bitnot,
    _squote,
    _asm,
    _str,
    _undefined,
    _hash,
    _module,
    _impl,
    _doublecolon,
    _import,
    _addeq,
    _muleq,
    _diveq,
    _subeq,
    _modeq,
    _bitandeq,
    _bitoreq,
    _bitxoreq,
    _bitnoteq,
    _shl,
    _shr,
    _shreq,
    _shleq,
    _plong,
    _switch,
    _range,
    _for,
    _pipe,
    _defer,
    _null,
    _cast,
    _argv,
    _bslash,
    _qmark,
    _sizeof,
    _alignof,
    _eof
}

struct Token {
    type:   TokType,
    value:  &u8,
    line:   u64,
    col:    u64
}

var current_line    = 0;
var current_column  = 0;
var current = 0;
var source_code:&u8 = undefined;

impl Token {
    init(type:TokType, value:&u8) *Token {
        var token_ptr = cast(*Token)malloc(sizeof(Token));
        token_ptr.* = Token {
            .type = type,
            .value = value,
            .line = current_line,
            .col = current_column
        };
        return token_ptr;
    }
}

var first_token = Token {};

fn more_tokens() bool {
    return current < source_code.len;
}

fn advance() void {
    current += 1;
    current_column += 1;
    return source_code[current - 1];
}

fn tokenize(source_code:&u8) *Token {
}


import "c.hyena"
