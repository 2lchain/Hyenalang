enum TokType {
    _plus,
    _minus,
    _multiply,
    _divide,
    _number,
    _undef,
    _leftparen,
    _rightparen,
    _semicolon,
    _colon,
    _identifier,
    _var,
    _equal,
    _leftbrace,
    _rightbrace,
    _bang,
    _greater,
    _less,
    _if,
    _else,
    _while,
    _break,
    _continue,
    _extern,
    _fn,
    _dot,
    _comma,
    _string,
    _return,
    _struct,
    _leftsquare,
    _rightsquare,
    _mod,
    _u8,
    _u16,
    _u32,
    _u64,
    _i8,
    _i16,
    _i32,
    _i64,
    _f32,
    _f64,
    _void,
    _true,
    _false,
    _bool,
    _eq,
    _neq,
    _lte,
    _gte,
    _union,
    _enum,
    _at,
    _and,
    _or,
    _bitxor,
    _bitand,
    _bitor,
    _bitnot,
    _squote,
    _asm,
    _str,
    _undefined,
    _hash,
    _module,
    _impl,
    _doublecolon,
    _import,
    _addeq,
    _muleq,
    _diveq,
    _subeq,
    _modeq,
    _bitandeq,
    _bitoreq,
    _bitxoreq,
    _bitnoteq,
    _shl,
    _shr,
    _shreq,
    _shleq,
    _plong,
    _switch,
    _range,
    _for,
    _pipe,
    _defer,
    _null,
    _cast,
    _argv,
    _bslash,
    _qmark,
    _sizeof,
    _alignof,
    _eof
}

struct Token {
    type:   TokType,
    value:  &u8,
    line:   u64,
    col:    u64
}

var current_line:u64    = 0;
var current_column:u64  = 0;
var current:u64         = 0;
var source_code:&u8 = undefined;
var eof:u8          = -1;

impl Token {
    init(type:TokType, value:&u8) *Token {
        var token_ptr = cast(*Token)malloc(sizeof(Token));
        token_ptr.* = Token {
            .type = type,
            .value = value,
            .line = current_line,
            .col = current_column
        };
        return token_ptr;
    }
}

var first_token = Token {};

fn token_error(message:&u8, args:argv) void {
    fmt::print("current_file:%q:%q ", .{current_line, current_column});
    fmt::println(message, args);
    exit(1);
}

fn more_tokens() bool {
    return current < source_code.len;
}

fn advance() void {
    current += 1;
    current_column += 1;
    return source_code[current - 1];
}

fn peek() u8 {
    if(more_tokens()) {
        return source_code[current];
    }
    return eof;
}

fn expect(char:u8) void {
    if(peek() == char) {
        advance();
        return;
    }

    token_error("Epected %c found %c", .{char, peek()});
    exit(1);
}

fn peek_next() u8 {
    if(source_code.len < current+2) return eof;
    return source_code[current+1];
}

fn peek_next_next() u8 {
    if(source_code.len < current+3) return eof;
    return source_code[current+2];
}

fn tokenize(code:&u8) *Token {
    source_code = code;
}


import "c.hyena"
import "fmt.hyena"
import "string.hyena"
